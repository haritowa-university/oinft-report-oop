\subsection{Инкапсуляция}
\label{sec:incapsulation}

Инкапсуляция позволяет объединить набор данных и методов в одну область видимости, за пределами которого эти методы и данные недосягаемы. Данный подход помогает поддерживать консистентность внутреннего состояния, скрывать сложность системы за небольшим интерфейсом. Во многих языках программирования данный концепт реализуется при помощи модификаторов доступа.

Однако, эта идея не пришла в программирование с появлением \gls{oop}. Язык C имеет прекрасную инкапсуляцию, которая достигается разделением файлов исходного кода на два вида: заголовочные файлы и файлы имлементации. Для примера, рассмотрим простую программу в листингах \ref{incapsulation:fake:1} и \ref{incapsulation:fake:2}. Потребители \texttt{point.h} не имеют доступа к содержимому \lstinline[language=C]{struct Point}. Для пользователя доступны только функции \lstinline[language=C]{makePoint()} и \lstinline[language=C]{distance()}, однако у них совершенно точно нет доступа к деталям имплементации структуры.

 Это и есть \textit{сокрытие реализации} в языке, не проектировавшимся с оглядкой на парадигму \gls{oop}. Позже появился \gls{oop} язык С++. Из-за технических причин(компилятору С++ нужно знать, сколько места в памяти будет занимать объект класса), все поля класса должны быть объявлены в заголовочном файле, что делает решение вопроса инкапсуляции прежними конструкциями невозможным. Как результат -- в языке появляются синтаксические конструкции для управлением областями видимости(модификаторы доступа). По своей сути, модификаторы доступа в С++ являются хаком, позволяющим восстановить инкапсуляцию. Java и C\# вовсе отменили разделение на заголовок и имплементацию, ослабив инкапсуляцию ещё сильнее. 

В некоторых ОО языках вовсе нет поддержки модификаторов доступа, существуют только конвенции именования(например, Ruby).