\subsection{Полиморфизм}
\label{sec:polymorphism}

Полиморфизм — слово греческого происхождения, означающее "многообразие форм" и имеющее несколько аспектов\cite{microsoft:poly}:
\begin{itemize}
	\item во время выполнения объекты производного класса могут обрабатываться как объекты базового класса в таких местах, как параметры метода и коллекции или массивы. Когда это происходит, объявленный тип объекта перестает соответствовать своему типу во время выполнения;
	\item Базовые классы могут определять и реализовывать виртуальные методы, а производные классы — переопределять их, т. е. предоставлять свое собственное определение и реализацию.
\end{itemize}

Часто, при определении термина полиморфизм, акцент делается на втором аспекте. Хорошим примером полиморфных функций в С является \lstinline[language=C]{getchar()}. Функция читает символ из STDIN, который может быть чем угодно и задаётся системой. Причина, по которой функция способна работать с разными драйверами в одинаковой манере, проста -- UNIX выставляет требования к драйверам, заставляя их предоставить пять стандартных функций с определёнными сигнатурами: 
\begin{itemize}
	\item open;
	\item close;
	\item read;
	\item write;
	\item seek.
\end{itemize}

Листинги \ref{fake:polymorphism:file}, \ref{fake:polymorphism:file_imp} иллюстрируют возможный процесс для создания собственного драйвера, способного работать с полиморфной функцией \lstinline[language=C]{getchar()}, а в листинге \ref{fake:polymorphism:getchar} находится возможная имплементация функции.

Этот постой трюк является основой почти для всего полиморфизма в ОО. В C++, например, существует таблица виртуальных методов(\texttt{vtable}), через которую идут все вызовы виртуальных функций. Конструкторы наследников просто заменяют значения родителей в таблице на переопределённые функции. Другими словами, полиморфизм является скорее удобным приложением к ссылкам на функции.
