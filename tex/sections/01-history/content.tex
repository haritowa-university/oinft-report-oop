\section{Определение ООП}\label{sec:history}

Существует огромное количество попыток дать понятное определение термину \gls{oop}. Часто упоминаемой является фраза <<комбинацию состояния и поведения>>. Данный ответ является неприемлимым, так как подразумевает, что вызовы \lstinline[language=C]{o.f()} и \lstinline[language=C]{f(o)} как-то кардинально отличаются.

Другим привычным ответом является <<Парадигма, при котором программа моделирует реальный мир>>. В лучшем случае, это определение уклончиво. Тем не менее, это определение показывает одну из черт \gls{oop} -- программный код, спроектированный в терминах ОО, более простой для понимания, так как он имеет более тесную связь с реальным миром.

Часто определение выводится через три основных принципа \gls{oop}:
\begin{itemize}
	\item инкапсуляция;
	\item наследование;
	\item полиморфизм.
\end{itemize}

Предполагается, что \gls{oop} -- правильная комбинация перечисленных выше принципов, однако, так же подразумевается, что именно \gls{oop} ответственен за их появление, что будет оспорено в следующих разделах.

Перед введением всего понятия \gls{oop}, стоит ввести ключевые понятия и рассмотреть основные принципы.